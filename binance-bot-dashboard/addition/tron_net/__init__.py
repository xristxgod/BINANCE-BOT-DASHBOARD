import json
from tronpy.tron import Tron, HTTPProvider, PrivateKey

from addition.config import _network, _node_url, fileTokens, decimals
from addition.utils import from_sun, to_sun

class TokenDB:

    @staticmethod
    def get_token():
        """Get information from a file"""
        try:
            with open(fileTokens, "r", encoding="utf-8") as file:
                tokens = json.loads(file.read())
            for token in tokens:
                if token["symbol"] == "USDT":
                    return token
        except Exception as error:
            raise error

class NodeTron:
    # Provider config
    __provider = HTTPProvider(_node_url)
    # Network
    network: str = _network

    # Converts
    fromSun = staticmethod(from_sun)
    toSun = staticmethod(to_sun)

    # Token db
    db = TokenDB()

    def __init__(self):
        """Connect to Tron Node"""
        self.node = Tron(
            provider=self.__provider if self.network == "mainnet" else None,
            network=self.network
        )

    def get_balance(self, address):
        """Get TRX balance"""
        balance = self.node.get_account_balance(addr=address)
        return decimals.create_decimal("%.8f" % balance) if balance > 0 else 0

    def get_token_balance(self, address):
        """
        Get TRC20 tokens balance
        :param address: Wallet address
        :param token: Token symbol or contract address
        """
        balance = 0
        token_dict = self.db.get_token()
        # Connecting to a smart contract
        result = self.node.get_contract(addr=token_dict["address"]).functions.balanceOf(address)
        if int(result) > 0:
            balance = decimals.create_decimal(result) / decimals.create_decimal(10 ** token_dict["decimals"])
        return decimals.create_decimal("%.8f" % balance) if float(balance) > 0 else balance

    def get_account_energy(self, address):
        """
        Returns energy data from account.
        :param address: Address of account
        """
        account_resources = self.node.get_account_resource(address)
        energy = account_resources["EnergyLimit"] if "EnergyLimit" in account_resources else 0
        energy_used = account_resources["EnergyUsed"] if "EnergyUsed" in account_resources else 0
        total_energy = energy - energy_used if energy > 0 and energy_used > 0 else 0
        return {
            "energy": energy,
            "energyUsed": energy_used,
            "totalEnergy": total_energy
        }

    def get_energy(self, address: str, energy: int) -> int:
        """If the user has enough energy."""
        total_energy = self.get_account_energy(address=address)["totalEnergy"]
        if int(total_energy) <= 0:
            return energy
        elif energy - int(total_energy) <= 0:
            return 0
        else:
            return energy - int(total_energy)

    def get_chain_parameters_by_name(self, name: str) -> int:
        parameters = self.node.get_chain_parameters()
        for parameter in parameters:
            if parameter["key"] == name:
                return parameter["value"]
        else:
            return 0

    def calculate_burn_energy(self, amount) -> float:
        """
        Returns the amount of energy generated by burning TRX
        :param amount: Amount of TRX in sun
        :return:
        """
        energy_fee = self.get_chain_parameters_by_name(name="getEnergyFee")
        if float(energy_fee) == 0:
            return decimals.create_decimal(0)
        fee = (amount / energy_fee) * 1_000_000
        return decimals.create_decimal(fee)

    def get_account_bandwidth(self, address):
        """
        Returns bandwidth data from account.
        :param address: Address of account
        """
        account_resources = self.node.get_account_resource(address)
        free_bandwidth = account_resources["freeNetLimit"] if "freeNetLimit" in account_resources else 0
        free_bandwidth_used = account_resources["freeNetUsed"] if "freeNetUsed" in account_resources else 0
        total_bandwidth = free_bandwidth - free_bandwidth_used
        return {
            "freeBandwidth": free_bandwidth,
            "freeBandwidthUsed": free_bandwidth_used,
            "totalBandwidth": total_bandwidth
        }

    def get_optimal_fee(self, from_address, to_address):
        token_dict = self.db.get_token()
        contract = self.node.get_contract(addr=token_dict["address"])
        if float(contract.functions.balanceOf(to_address)) > 0:
            energy = token_dict["isBalanceNotNullEnergy"]
        else:
            energy = token_dict["isBalanceNullEnergy"]
        fee = self.get_energy(address=from_address, energy=energy) / self.calculate_burn_energy(1)
        bd = token_dict["bandwidth"]
        if int(self.get_account_bandwidth(address=from_address)["totalBandwidth"]) <= bd:
            fee += decimals.create_decimal(267) / 1_000
        return decimals.create_decimal("%.8f" % fee) if fee > 0 else fee

    def create_sign_transaction(self, from_address, to_address, amount, from_private_key):
        """Create a transaction TRX"""
        # Checks the correctness of the data entered by users
        amount = self.toSun(float(amount))
        # Resources that will go to the transaction
        resources = self.get_optimal_fee(from_address=from_address, to_address=to_address)
        # Creates and build a transaction
        txn = self.node.trx.transfer(from_=from_address, to=to_address, amount=amount).build()
        sign_transaction = txn.sign(priv_key=PrivateKey(private_key_bytes=bytes.fromhex(from_private_key)))
        sign_transaction.broadcast().wait()
        return sign_transaction.txid

    def create_sign_trc20_transactions(self, from_address, to_address, amount, from_private_key):
        """Create a transaction TRC20"""
        # Token information
        token_dict = self.db.get_token()
        # Connecting to a smart contract
        contract = self.node.get_contract(addr=token_dict["address"])
        # Let's get the amount for the offspring in decimal
        amount = int(float(amount) * 10 ** int(token_dict["decimals"]))
        # Checks whether the user has a tokens balance to transfer
        if contract.functions.balanceOf(from_address) * 10 ** int(token_dict["decimals"]) < amount:
            raise Exception("You do not have enough funds on your balance to make a transaction!!!")
        # Creating a transaction
        txn = contract.functions.transfer(to_address, amount).with_owner(from_address).build()
        sign_transaction = txn.sign(priv_key=PrivateKey(private_key_bytes=bytes.fromhex(from_private_key)))
        sign_transaction.broadcast().wait()
        return sign_transaction.txid

tron_node = NodeTron()